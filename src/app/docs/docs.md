
# üìñ Solnado Documentation

Welcome to the Solnado App docs! Below you‚Äôll find:

- On-chain **Merkle Mountain Range** architecture  
- Leaf parsing via **Base64 memos**  
- **Client-side** SNARK‚Äêproof offloading  
- Roadmap: nullifier storage, multi-asset support, RPC endpoints  

---

## Merkle Tree Architecture

We maintain a **Merkle Mountain Range (MMR)** on‚Äêchain, storing only *peaks* plus a 16‚Äêleaf in‚Äêflight buffer. Each batch is a 16‚Äêleaf subtree (2‚Å¥), whose root merges immediately into the MMR. By keeping only the current 16‚Äêslot buffer **plus** peak array (`[depth, root]` pairs) on‚Äêchain, all prove/deepen/roll‚Äêup ops run in _O(log N)_ time without storing millions of leaves. 
A leaf is a hash of 3 values: ```js 
hash(amount|nullifier|assetId)
``` 
This allows for ZK proofs that leaves being deposited or funds being transfered correspond to actual amounts that are locked in the pool.
Transfers work by proving that you know the preimage to one (or two) of the leaves of the pool and that the amount written on the leaf you're adding to the tree is equal to the amount on the leaves you're using and nullifying.
For withdrawal, given the correct computed proof, a third party can withdraw securely towards a wallet of you're choosing to avoid having to fund a gas-less wallet.

---

## Efficient Leaf Parsing with Memos

At each sub‚Äêbatch (8 leaves) and full‚Äêbatch (16 leaves), we emit a **Base64 memo** via the Solana Memo program. Payload format:

```text
batchNumber (8 bytes BE) ‚Äñ leaf0 (32 bytes) ‚Äñ ‚Ä¶ ‚Äñ leafN (32 bytes)
````

Off‚Äêchain indexers can call

```js
getSignaturesForAddress(LeavesIndexerPDA, ‚Ä¶)
```

and replay memos to reconstruct up to 8 000 leaves in a single 1 000-signature fetch. On top of that a small tree indexer is used to check avoid parsing the whole tree and toget the siblings path. It is used every 10^16 transaction.These two methods combined make a finding the to path for a leaf in a 1 billion leaves tree achievable with a maximum of 10 RPC calls.

---

## Client‚ÄêSide Offloading

All SNARK‚Äêproof generation, public‚Äêinput packing, Merkle‚Äêroot recomputation, and memo parsing are generated by the client. The on‚Äêchain program **only** verifies proofs and enforces correct memo‚ÄêPDA inclusion‚Äîeverything else runs in the browser. This allows for further scaling without the need of central server to store the gigabytes of data.

---

## Work in Progress & Next Steps
* **Nullifier storage:** introduce a sharded PDA or Merkle‚Äêbased accumulator for spent‚Äênote proofs, bringing the cost of storage from 0.0009SOL to 0.00023SOL per nullifier (w/ SOL@ $180 from 16¬¢ to 4¬¢).
* **Multi‚Äêasset support:** Open deposits to SPL tokens, and NFTs in the same pool. The leaf format allows this but current anchor compatibility issues have halted the development of this feature.
* **Inbox system** Allow a user depositing funds to add an encrypted message only decryptable by the recipient using
* **Wallet Integration** Design a wallet that stores the commitments and keeps tracks of users transactions
* **Further testing** Especially when the tree gets bigger, check that nullifier accounts correctly scale, that leaf parsing remains efficient.
 
* **Make a DAO** As a anonymity tool, the end goal is to make this community-owned and allow for a community of passionates to contribute to the future of encrypted DeFi.
