
# 📖 Solnado Documentation

Welcome to the Solnado App docs! Below you’ll find:

- On-chain **Merkle Mountain Range** architecture  
- Leaf parsing via **Base64 memos**  
- **Client-side** SNARK‐proof offloading  
- Roadmap: nullifier storage, multi-asset support, RPC endpoints  

---

## Merkle Tree Architecture

We maintain a **Merkle Mountain Range (MMR)** on‐chain, storing only *peaks* plus a 16‐leaf in‐flight buffer. Each batch is a 16‐leaf subtree (2⁴), whose root merges immediately into the MMR. By keeping only the current 16‐slot buffer **plus** peak array (`[depth, root]` pairs) on‐chain, all prove/deepen/roll‐up ops run in _O(log N)_ time without storing millions of leaves. 
A leaf is a hash of 3 values: ```js 
hash(amount|nullifier|assetId)
``` 
This allows for ZK proofs that leaves being deposited or funds being transfered correspond to actual amounts that are locked in the pool.
---

## Efficient Leaf Parsing with Memos

At each sub‐batch (8 leaves) and full‐batch (16 leaves), we emit a **Base64 memo** via the Solana Memo program. Payload format:

```text
batchNumber (8 bytes BE) ‖ leaf0 (32 bytes) ‖ … ‖ leafN (32 bytes)
````

Off‐chain indexers can call

```js
getSignaturesForAddress(LeavesIndexerPDA, …)
```

and replay memos to reconstruct up to 8 000 leaves in a single 1 000-signature fetch. On top of that a small tree indexer is used to check avoid parsing the whole tree and toget the siblings path. It is used every 10^16 transaction.These two methods combined make a finding the to path for a leaf in a 1 billion leaves tree achievable with a maximum of 10 RPC calls.

---

## Client‐Side Offloading

All SNARK‐proof generation, public‐input packing, Merkle‐root recomputation, and memo parsing are generated by the client. The on‐chain program **only** verifies proofs and enforces correct memo‐PDA inclusion—everything else runs in the browser. This allows for further scaling without the need of central server to store the gigabytes of data.

---

## Work in Progress & Next Steps
* **Nullifier storage:** introduce a sharded PDA or Merkle‐based accumulator for spent‐note proofs, bringing the cost of storage from 0.0009SOL to 0.00023SOL per nullifier (w/ SOL@ $180 from 16¢ to 4¢).
* **Multi‐asset support:** Open deposits to SPL tokens, and NFTs in the same pool. The leaf format allows this but current anchor compatibility issues have halted the development of this feature.
* **Inbox system** Allow a user depositing funds to add an encrypted message only decryptable by the recipient using
* **Wallet Integration** Design a wallet that stores the commitments and keeps tracks of users transactions
* **Further testing** Especially when the tree gets bigger, check that nullifier accounts correctly scale, that leaf parsing remains efficient.
 
* **Make a DAO** As a anonymity tool, the end goal is to make this community-owned and allow for a community of passionates to contribute to the future of encrypted DeFi.
